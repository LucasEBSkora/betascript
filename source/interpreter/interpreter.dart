import 'dart:collection' show HashMap;

import 'expr.dart';
import 'directive_manager.dart';
import 'function_adapter.dart';
import 'native_globals.dart';
import 'stmt.dart';
import 'token.dart';
import 'user_routine.dart';
import 'betascript.dart';
import 'callable.dart';
import 'class.dart';
import 'environment.dart';
import 'instance.dart';
import '../logic/logic.dart';
import '../sets/sets.dart';
import '../utils/three_valued_logic.dart';
import '../function/functions.dart';
import '../function/utils.dart' show toNums;

class BSInterpreter implements ExprVisitor, StmtVisitor {
  final Environment globals = Environment.from(nativeGlobals); //Global scope

  //Stores the results generated by Resolver
  final HashMap<Expr, int> _locals = HashMap();
  Environment _environment = Environment(); //Current scope

  DirectiveManager directives = DirectiveManager();

  BSInterpreter() {
    _environment = globals;
  }

  void interpret(List<Stmt> statements) {
    try {
      for (var stmt in statements) {
        _execute(stmt);
      }
    } on RuntimeError catch (e) {
      BetaScript.runtimeError(e);
    }
  }

  void _execute(Stmt stmt) => stmt.accept(this);

  String _stringify(object) => object?.toString() ?? 'nil';

  @override
  Object visitBinaryExpr(BinaryExpr e) {
    final leftOperand = _evaluate(e.left);
    final rightOperand = _evaluate(e.right);

    //operations for functions
    if (leftOperand is BSFunction && rightOperand is BSFunction) {
      final nums = toNums(leftOperand, rightOperand);
      if (nums != null) {
        switch (e.op.type) {
          case TokenType.minus:
            return leftOperand - rightOperand;
          case TokenType.slash:
            return leftOperand / rightOperand;
          case TokenType.star:
            return leftOperand * rightOperand;
          case TokenType.exp:
            return leftOperand ^ rightOperand;
          case TokenType.plus:
            return leftOperand + rightOperand;
          case TokenType.greater:
            return nums.first > nums.second;
          case TokenType.greaterEqual:
            return nums.first >= nums.second;
          case TokenType.less:
            return nums.first < nums.second;
          case TokenType.lessEqual:
            return nums.first <= nums.second;
          // equals returns logic expressions for functions and logical values for everything else
          case TokenType.equals:
            return nums.first == nums.second;
          // identicallyEquals always returns logical values
          case TokenType.identicallyEquals:
            return _isEqual(leftOperand, rightOperand);
          default:
            throw RuntimeError(
                e.op, "operation '${e.op}' not supported for functions");
        }
      }

      switch (e.op.type) {
        case TokenType.minus:
          return leftOperand - rightOperand;
        case TokenType.slash:
          return leftOperand / rightOperand;
        case TokenType.star:
          return leftOperand * rightOperand;
        case TokenType.exp:
          return leftOperand ^ rightOperand;
        case TokenType.plus:
          return leftOperand + rightOperand;
        case TokenType.greater:
          return GreaterThan(leftOperand, rightOperand);
        case TokenType.greaterEqual:
          return GreaterOrEqual(leftOperand, rightOperand);
        case TokenType.less:
          return LessThan(leftOperand, rightOperand);
        case TokenType.lessEqual:
          return LessOrEqual(leftOperand, rightOperand);
        // equals returns logic expressions for functions and logical values for everything else
        case TokenType.equals:
          return Equal(leftOperand, rightOperand);
        // identicallyEquals always returns logical values
        case TokenType.identicallyEquals:
          return _isEqual(leftOperand, rightOperand);
        default:
          throw RuntimeError(
              e.op, "operation '${e.op}' not supported for functions");
      }
    }

    //operations for sets
    if (leftOperand is BSSet && rightOperand is BSSet) {
      switch (e.op.type) {
        case TokenType.minus:
        case TokenType.slash:
          return leftOperand.relativeComplement(rightOperand);

        case TokenType.star:
          return leftOperand.intersection(rightOperand);
        case TokenType.plus:
          return leftOperand.union(rightOperand);
        // equals returns logic expressions for functions and logical values for everything else
        // identicallyEquals always returns logical values
        case TokenType.equals:
        case TokenType.identicallyEquals:
          return _isEqual(leftOperand, rightOperand);
        default:
          throw RuntimeError(
              e.op, "operation '${e.op}' not supported for sets");
      }
    }

    //operation for string
    if (e.op.type == TokenType.plus) {
      if (leftOperand is String && rightOperand is String) {
        return leftOperand + rightOperand;
      }
      if (leftOperand is String) return leftOperand + rightOperand.toString();
      if (rightOperand is String) return leftOperand.toString() + rightOperand;
    }

    throw RuntimeError(e.op,
        "operation '${e.op}' not supported for values $leftOperand and $rightOperand");
  }

  @override
  visitGroupingExpr(GroupingExpr e) => _evaluate(e.expression);

  @override
  Object? visitLiteralExpr(LiteralExpr e) => e.value;

  @override
  visitUnaryExpr(UnaryExpr e) {
    final operand = _evaluate(e.operand);

    switch (e.op.type) {
      case TokenType.minus:
        _checkNum(e.op, operand);
        return -(operand as BSFunction);
      case TokenType.not:
        return !_istruthy(operand);
      //"not" (!) would be here, but i decided to use it for factorials and use the "not" keyword explicitly
      case TokenType.approx:
        if (operand is BSFunction) return operand.approx;
        if (operand is BuilderSet) return operand.knownElements;
        throw RuntimeError(e.op,
            "The approximation (~) operator may only be applied to functions and builder sets");
      case TokenType.apostrophe:
        if (operand is BSFunction) {
          final params = operand.parameters;
          if (params.length > 1) {
            throw RuntimeError(e.op,
                "the apostrophe operator may only be applied to functions defined in a single (or no) variables");
          }
          if (params.length == 1) {
            return operand.derivative(params.last);
          } else {
            //functions defined in 0 variables are always constant, so their derivative is 0
            return 0;
          }
        }
        if (operand is BSSet) return operand.complement();
        throw RuntimeError(e.op,
            "The apostrophe operator may only be applied to functions and sets");
      case TokenType.factorial:
        throw RuntimeError(e.op, "error! factorial not yet implemented");
      default:
        return null;
    }
  }

  Object? _evaluate(Expr e) => e.accept(this);

  ///[null], [false], [unknown] and [emptySet] are "falsy", everything else is "truthy"
  ///(isn't the value 'true' but can be used in logic as if it was)
  static bool _istruthy(Object? object) {
    if (object is BSLogical) return object.asBool();
    return (object != false) && (object != null) && (object != emptySet);
  }

  static _isEqual(Object? a, Object? b) {
    if (a == null && b == null) return true; //null is only equal to null
    if (a == null || b == null) return false;

    return a == b;
  }

  static void _checkNum(Token token, Object? value) {
    if (!(value is BSFunction)) {
      throw RuntimeError(token, "Operand for ${token.lexeme} must be function");
    }
  }

  @override
  void visitExpressionStmt(ExpressionStmt stmt) => _evaluate(stmt.expression);

  @override
  void visitPrintStmt(PrintStmt stmt) {
    var value = _evaluate(stmt.expression);

    //calls the appropriate print function
    BetaScript.printCallback(_stringify(value));
  }

  @override
  void visitVarStmt(VarStmt s) {
    //checks for parameters (which only exist in function declarations)
    List<Variable> _variables = <Variable>[];
    if (s.parameters.isNotEmpty) {
      //Checks if each of the parameters is already a Variable, and when they don't exist, create them as variables
      for (Token parameter in s.parameters) {
        var _variable = _environment.search(parameter);
        if (_variable == null) {
          _variable = variable(parameter.lexeme);
          _environment.define(parameter.lexeme, _variable);
        } else if (!(_variable is Variable)) {
          throw RuntimeError(
              parameter, "Parameters to a function must always be Variables");
        }

        _variables.add(_variable as Variable);
      }

      //checks if there are any duplicate variables (not supported)

      for (int i = 0; i < _variables.length; ++i)
        for (int j = i + 1; j < _variables.length; ++j)
          if (_variables[i] == _variables[j]) {
            throw RuntimeError(s.name,
                "Duplicate parameters not allowed in function variables");
          }
    }


    var value;
    if (s.initializer != null) {
      value = _evaluate(s.initializer!);
    }
    if (_variables.isNotEmpty && value == null) {
      throw RuntimeError(s.name,
          "Function variable declarations with explicit parameter lists must always be initialized");
    } else if (_variables.isNotEmpty && !(value is BSFunction)) {
      throw RuntimeError(
          s.name, "Only function variable declarations may include parameters");
    } else if (_variables.isNotEmpty && value is BSFunction) {
      value = value.withParameters(_variables.toSet());
    }

    _environment.define(s.name.lexeme, value);
  }

  @override
  Object visitVariableExpr(VariableExpr e) => _lookUpVariable(e.name, e);

  @override
  visitAssignExpr(AssignExpr e) {
    final value = _evaluate(e.value);

    int? distance = _locals[e];
    if (distance != null) {
      _environment.assignAt(distance, e.name, value);
    } else {
      globals.assign(e.name, value);
    }

    return value;
  }

  @override
  void visitBlockStmt(BlockStmt s) {
    //Creates a new environment with current environment enclosing it
    executeBlock(s.statements, Environment(_environment));
  }

  ///Parameters here are the list of statements to run and
  ///the environment in which to run them
  void executeBlock(List<Stmt> statements, Environment environment) {
    var previous = _environment;
    try {
      _environment = environment;
      for (Stmt s in statements) _execute(s);
    } finally {
      _environment = previous;
    }
  }

  @override
  void visitIfStmt(IfStmt s) {
    if (_istruthy(_evaluate(s.condition)))
      _execute(s.thenBranch);
    else if (s.elseBranch != null) _execute(s.elseBranch!);
  }

  @override
  Object? visitLogicBinaryExpr(LogicBinaryExpr e) {
    final left = _evaluate(e.left);

    //operations with unknown always result in unknown
    if (left == bsUnknown) return bsUnknown;

    final right = _evaluate(e.right);

    if (right == bsUnknown) return bsUnknown;

    if (e.op.type == TokenType.or) {
      if (_istruthy(left)) return left!;
    } else if (!_istruthy(left)) return left!;
    return right;
  }

  @override
  void visitWhileStmt(WhileStmt s) {
    if (directives.getDirective("bs_tt_interpret") as bool) {
      throw RuntimeError(
          s.token, "loops are forbidden when interpreting for twitter");
    }
    while (_istruthy(_evaluate(s.condition))) _execute(s.body);
  }

  @override
  visitCallExpr(CallExpr e) {
    var callee = _evaluate(e.callee);

    //wraps BSFunctions in the adapter in order to use the BSCallable interface
    if (callee is BSFunction) {
      callee = FunctionAdapter(callee);
    } else if (!(callee is BSCallable)) {
      throw RuntimeError(
          e.paren, "Can only call routines, functions and classes.");
    }

    if (directives.getDirective("bs_tt_interpret") as bool &&
        !(callee is BSFunction || callee is BSClass)) {
      throw RuntimeError(e.paren,
          "when interpreting for twitter, you can only call functions and constructors");
    }

    final arguments = <Object?>[
      for (final argument in e.arguments) _evaluate(argument)
    ];

    BSCallable function = callee as BSCallable;

    if (arguments.length != function.arity) {
      throw RuntimeError(e.paren,
          "Expected ${function.arity.toString()} paramenters, but got ${arguments.length.toString()}.");
    }
    if (callee is FunctionAdapter) {
      for (var a in arguments)
        if (!(a is BSFunction)) {
          throw RuntimeError(
              e.paren, "functions only support other functions as parameters.");
        }
    }

    return function.callThing(this, arguments);
  }

  @override
  void visitRoutineStmt(RoutineStmt s) {
    if (directives.getDirective("bs_tt_interpret") as bool) {
      throw RuntimeError(s.name,
          "routine definitions are forbidden when interpreting for twitter");
    }
    UserRoutine routine = UserRoutine(s, _environment, false);
    _environment.define(s.name.lexeme, routine);
  }

  @override
  void visitReturnStmt(ReturnStmt s) {
    throw Return(_evaluate(s.value));
  }

  ///Adds a resolved variable from [Resolver] to the map
  void resolve(Expr e, int depth) {
    _locals[e] = depth;
  }

  ///Retrieves a variable value from the [Environment]. Do remember that the
  ///[Resolver] doesn't deal with global variables,
  ///which are stored directly in globals
  Object _lookUpVariable(Token name, Expr e) {
    var distance = _locals[e];
    if (distance != null) {
      return _environment.getAt(distance, name.lexeme);
    } else {
      return globals.get(name);
    }
  }

  @override
  void visitClassStmt(ClassStmt s) {
    if (directives.getDirective("bs_tt_interpret") as bool) {
      throw RuntimeError(s.name,
          "class definitions are forbidden when interpreting for twitter");
    }
    var superclass;
    if (s.superclass != null) {
      superclass = _evaluate(s.superclass!);
      if (!(superclass is BSClass)) {
        throw RuntimeError(s.superclass!.name, "Superclass must be a class");
      }
    }

    _environment.define(s.name.lexeme);

    //Creates a new closure containing super, which contains all the methods
    if (s.superclass != null) {
      _environment = Environment(_environment);
      _environment.define("super", superclass);
    }

    final methods = HashMap<String, UserRoutine>();

    for (final method in s.methods)
      methods[method.name.lexeme] = UserRoutine(
          method, _environment, method.name.lexeme == s.name.lexeme);

    final bsclass = BSClass(s.name.lexeme, superclass, methods);

    if (superclass != null) _environment = _environment.enclosing!;

    _environment.assign(s.name, bsclass);
  }

  @override
  visitGetExpr(GetExpr e) {
    var object = _evaluate(e.object);
    if (object is BSInstance) {
      return object.get(e.name);
    }
    throw RuntimeError(e.name, "Only instances have properties");
  }

  @override
  visitSetExpr(SetExpr e) {
    var object = _evaluate(e.object);

    if (!(object is BSInstance)) {
      throw RuntimeError(e.name, "Only instances have fields");
    }

    var value = _evaluate(e.value);
    object.set(e.name, value);
    return value;
  }

  @override
  Object visitThisExpr(ThisExpr e) => _lookUpVariable(e.keyword, e);

  @override
  Object visitSuperExpr(SuperExpr e) {
    var distance = _locals[e]!;
    BSClass superclass = _environment.getAt(distance, "super") as BSClass;

    //'this' is always contained one closure "inner" than 'super'
    var object = _environment.getAt(distance - 1, "this");

    //finds the method in the superclass and binds it to 'this'
    var method = superclass.findMethod(e.method.lexeme);

    if (method == null) {
      throw RuntimeError(e.method, "Undefined property '${e.method.lexeme}'.");
    }

    return method.bind(object as BSInstance);
  }

  @override
  visitDerivativeExpr(DerivativeExpr e) {
    var f = _evaluate(e.derivand);
    if (!(f is BSFunction)) {
      throw RuntimeError(e.keyword, "target of derivative must be function");
    }
    var _variables = <Variable>[];
    for (Expr exp in e.variables) {
      var v = _evaluate(exp);
      if (v is Variable) {
        _variables.add(v);
      } else {
        throw RuntimeError(
            e.keyword, "Functions may only be derivated in variables");
      }
    }
    BSFunction _value = f;
    for (Variable v in _variables) _value = _value.derivative(v);
    return _value;
  }

  @override
  void visitDirectiveStmt(DirectiveStmt s) {
    if (!directives.isGlobal(s.directive)) {
      directives.setDirective(s.directive, true);
      print("local directive ${s.directive} set");
    }
  }

  @override
  visitBuilderDefinitionExpr(BuilderDefinitionExpr e) {
    final parameters = <Variable>[];

    if (e.parameters.isNotEmpty) {
      //Checks if each of the parameters is already a Variable, and when they don't exist, create them as variables
      for (Token parameter in e.parameters) {
        var _variable = _environment.search(parameter);
        if (_variable == null) {
          _variable = variable(parameter.lexeme);
          _environment.define(parameter.lexeme, _variable);
        } else if (!(_variable is Variable)) {
          throw RuntimeError(
              parameter, "Parameters to a function must always be Variables");
        }

        parameters.add(_variable as Variable);
      }
    }
    var rule = _evaluate(e.rule);
    if (rule is LogicExpression) {
      return builderSet(rule, parameters);
    } else {
      throw RuntimeError(
          e.bar, "Builder set definitions must contain comparisons!");
    }
  }

  @override
  visitIntervalDefinitionExpr(IntervalDefinitionExpr e) {
    var _a = _evaluate(e.a);
    var _b = _evaluate(e.b);
    if (_a is BSFunction && _b is BSFunction) {
      var nums = toNums(_a, _b);
      if (nums == null) {
        throw RuntimeError(
            e.left, "Interval definitions must have both edges be numbers");
      }
      return interval(_a, _b,
          leftClosed: e.left.lexeme == '[', rightClosed: e.right.lexeme == ']');
    } else
      throw RuntimeError(
          e.left, "Interval definitions must have both edges be numbers");
  }

  @override
  visitRosterDefinitionExpr(RosterDefinitionExpr e) {
    var elements = <BSFunction>[];

    for (var expr in e.elements) {
      var el = _evaluate(expr);
      if (el is BSFunction) {
        elements.add(el);
        continue;
      }
      throw RuntimeError(
          e.left, "Roster sets can only be defined in constant functions!");
    }

    try {
      return rosterSet(elements);
    } on SetDefinitionError catch (exception) {
      throw RuntimeError(e.left, exception.message);
    }
  }

  @override
  visitSetBinaryExpr(SetBinaryExpr e) {
    var left = _evaluate(e.left);
    var right = _evaluate(e.right);

    if (right is BSSet) {
      if (left is BSSet) {
        switch (e.operator.type) {
          case TokenType.union:
            return left.union(right);
          case TokenType.intersection:
            return left.intersection(right);
          case TokenType.disjoined:
            return left.disjoined(right);
          case TokenType.invertedSlash:
            return left.relativeComplement(right);
          case TokenType.contained:
            return right.contains(left);
          case TokenType.belongs:
            throw RuntimeError(
                e.operator, "left operand for this operation must be a number");
          default:
            throw RuntimeError(e.operator, "not a valid set operator!");
        }
      } else {
        if (left is BSFunction &&
            e.operator.type == TokenType.belongs &&
            left.toNum() != null) {
          return right.belongs(left);
        }
        throw RuntimeError(
            e.operator, "left operand not valid for this operator");
      }
    }
    throw RuntimeError(
        e.operator, "this operation must be done exclusively on sets");
  }

  @override
  Object visitExplainExpr(ExplainExpr e) {
    final expr = e.operand;

    if (expr is UnaryExpr) {
      if (expr.op.type == TokenType.apostrophe) {
        final operand = _evaluate(expr.operand);
        if (operand is BSFunction) {
          final params = operand.parameters;
          if (params.length > 1) {
            throw RuntimeError(expr.op,
                "the apostrophe operator may only be applied to functions defined in a single (or no) variables");
          } else
            return operand.explainedDerivative(params.last);
        }
      }
      return visitUnaryExpr(expr);
    } else if (expr is DerivativeExpr) {
      var f = _evaluate(expr.derivand);
      if (!(f is BSFunction)) {
        throw RuntimeError(e.keyword, "target of derivative must be function");
      }
      var _variables = <Variable>[];
      for (Expr exp in expr.variables) {
        var v = _evaluate(exp);
        if (v is Variable) {
          _variables.add(v);
        } else {
          throw RuntimeError(
              e.keyword, "Functions may only be derivated in variables");
        }
      }
      BSFunction _value = f;
      String result = "";
      for (Variable v in _variables) {
        result += _value.explainedDerivative(v);
        _value = _value.derivative(v);
      }
      return result;
    }
    return '';
  }
}

class RuntimeError implements Exception {
  final Token token;
  final String message;

  RuntimeError(this.token, this.message);

  @override
  String toString() => "Runtime Error: $message at line ${token.line}";
}

class Return implements Exception {
  final value;

  Return(this.value);
}
